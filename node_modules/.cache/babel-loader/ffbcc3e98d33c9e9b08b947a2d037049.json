{"ast":null,"code":"/*!\n * wordcloud2.js\n * http://timdream.org/wordcloud2.js/\n *\n * Copyright 2011 - 2013 Tim Chien\n * Released under the MIT license\n */\n'use strict'; // setImmediate\n\nrequire(\"core-js/modules/web.immediate.js\");\n\nif (!window.setImmediate) {\n  window.setImmediate = function setupSetImmediate() {\n    return window.msSetImmediate || window.webkitSetImmediate || window.mozSetImmediate || window.oSetImmediate || function setupSetZeroTimeout() {\n      if (!window.postMessage || !window.addEventListener) {\n        return null;\n      }\n\n      var callbacks = [undefined];\n      var message = 'zero-timeout-message'; // Like setTimeout, but only takes a function argument.  There's\n      // no time argument (always zero) and no arguments (you have to\n      // use a closure).\n\n      var setZeroTimeout = function setZeroTimeout(callback) {\n        var id = callbacks.length;\n        callbacks.push(callback);\n        window.postMessage(message + id.toString(36), '*');\n        return id;\n      };\n\n      window.addEventListener('message', function setZeroTimeoutMessage(evt) {\n        // Skipping checking event source, retarded IE confused this window\n        // object with another in the presence of iframe\n        if (typeof evt.data !== 'string' || evt.data.substr(0, message.length) !== message\n        /* ||\n        evt.source !== window */\n        ) {\n          return;\n        }\n\n        evt.stopImmediatePropagation();\n        var id = parseInt(evt.data.substr(message.length), 36);\n\n        if (!callbacks[id]) {\n          return;\n        }\n\n        callbacks[id]();\n        callbacks[id] = undefined;\n      }, true);\n      /* specify clearImmediate() here since we need the scope */\n\n      window.clearImmediate = function clearZeroTimeout(id) {\n        if (!callbacks[id]) {\n          return;\n        }\n\n        callbacks[id] = undefined;\n      };\n\n      return setZeroTimeout;\n    }() || // fallback\n    function setImmediateFallback(fn) {\n      window.setTimeout(fn, 0);\n    };\n  }();\n}\n\nif (!window.clearImmediate) {\n  window.clearImmediate = function setupClearImmediate() {\n    return window.msClearImmediate || window.webkitClearImmediate || window.mozClearImmediate || window.oClearImmediate || // \"clearZeroTimeout\" is implement on the previous block ||\n    // fallback\n    function clearImmediateFallback(timer) {\n      window.clearTimeout(timer);\n    };\n  }();\n}\n\n(function (global) {\n  // Check if WordCloud can run on this browser\n  var isSupported = function isSupported() {\n    var canvas = document.createElement('canvas');\n\n    if (!canvas || !canvas.getContext) {\n      return false;\n    }\n\n    var ctx = canvas.getContext('2d');\n\n    if (!ctx.getImageData) {\n      return false;\n    }\n\n    if (!ctx.fillText) {\n      return false;\n    }\n\n    if (!Array.prototype.some) {\n      return false;\n    }\n\n    if (!Array.prototype.push) {\n      return false;\n    }\n\n    return true;\n  }(); // Find out if the browser impose minium font size by\n  // drawing small texts on a canvas and measure it's width.\n\n\n  var minFontSize = function getMinFontSize() {\n    if (!isSupported) {\n      return;\n    }\n\n    var ctx = document.createElement('canvas').getContext('2d'); // start from 20\n\n    var size = 20; // two sizes to measure\n\n    var hanWidth, mWidth;\n\n    while (size) {\n      ctx.font = size.toString(10) + 'px sans-serif';\n\n      if (ctx.measureText('\\uFF37').width === hanWidth && ctx.measureText('m').width === mWidth) {\n        return size + 1;\n      }\n\n      hanWidth = ctx.measureText('\\uFF37').width;\n      mWidth = ctx.measureText('m').width;\n      size--;\n    }\n\n    return 0;\n  }(); // Based on http://jsfromhell.com/array/shuffle\n\n\n  var shuffleArray = function shuffleArray(arr) {\n    for (var j, x, i = arr.length; i; j = Math.floor(Math.random() * i), x = arr[--i], arr[i] = arr[j], arr[j] = x) {}\n\n    return arr;\n  };\n\n  var WordCloud = function WordCloud(elements, options) {\n    if (!isSupported) {\n      return;\n    }\n\n    if (!Array.isArray(elements)) {\n      elements = [elements];\n    }\n\n    elements.forEach(function (el, i) {\n      if (typeof el === 'string') {\n        elements[i] = document.getElementById(el);\n\n        if (!elements[i]) {\n          throw 'The element id specified is not found.';\n        }\n      } else if (!el.tagName && !el.appendChild) {\n        throw 'You must pass valid HTML elements, or ID of the element.';\n      }\n    });\n    /* Default values to be overwritten by options object */\n\n    var settings = {\n      list: [],\n      fontFamily: '\"Trebuchet MS\", \"Heiti TC\", \"微軟正黑體\", ' + '\"Arial Unicode MS\", \"Droid Fallback Sans\", sans-serif',\n      fontWeight: 'normal',\n      color: 'random-dark',\n      minSize: 0,\n      // 0 to disable\n      weightFactor: 1,\n      clearCanvas: true,\n      backgroundColor: '#fff',\n      // opaque white = rgba(255, 255, 255, 1)\n      gridSize: 8,\n      drawOutOfBound: false,\n      origin: null,\n      drawMask: false,\n      maskColor: 'rgba(255,0,0,0.3)',\n      maskGapWidth: 0.3,\n      wait: 0,\n      abortThreshold: 0,\n      // disabled\n      abort: function noop() {},\n      minRotation: -Math.PI / 2,\n      maxRotation: Math.PI / 2,\n      rotationStep: 0.1,\n      shuffle: true,\n      rotateRatio: 0.1,\n      shape: 'circle',\n      ellipticity: 0.65,\n      classes: null,\n      hover: null,\n      click: null\n    };\n\n    if (options) {\n      for (var key in options) {\n        if (key in settings) {\n          settings[key] = options[key];\n        }\n      }\n    }\n    /* Convert weightFactor into a function */\n\n\n    if (typeof settings.weightFactor !== 'function') {\n      var factor = settings.weightFactor;\n\n      settings.weightFactor = function weightFactor(pt) {\n        return pt * factor; //in px\n      };\n    }\n    /* Convert shape into a function */\n\n\n    if (typeof settings.shape !== 'function') {\n      switch (settings.shape) {\n        case 'circle':\n        /* falls through */\n\n        default:\n          // 'circle' is the default and a shortcut in the code loop.\n          settings.shape = 'circle';\n          break;\n\n        case 'cardioid':\n          settings.shape = function shapeCardioid(theta) {\n            return 1 - Math.sin(theta);\n          };\n\n          break;\n\n        /*\n        To work out an X-gon, one has to calculate \"m\",\n        where 1/(cos(2*PI/X)+m*sin(2*PI/X)) = 1/(cos(0)+m*sin(0))\n        http://www.wolframalpha.com/input/?i=1%2F%28cos%282*PI%2FX%29%2Bm*sin%28\n        2*PI%2FX%29%29+%3D+1%2F%28cos%280%29%2Bm*sin%280%29%29\n        Copy the solution into polar equation r = 1/(cos(t') + m*sin(t'))\n        where t' equals to mod(t, 2PI/X);\n        */\n\n        case 'diamond':\n        case 'square':\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n          // %28t%2C+PI%2F2%29%29%2Bsin%28mod+%28t%2C+PI%2F2%29%29%29%2C+t+%3D\n          // +0+..+2*PI\n          settings.shape = function shapeSquare(theta) {\n            var thetaPrime = theta % (2 * Math.PI / 4);\n            return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));\n          };\n\n          break;\n\n        case 'triangle-forward':\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n          // %28t%2C+2*PI%2F3%29%29%2Bsqrt%283%29sin%28mod+%28t%2C+2*PI%2F3%29\n          // %29%29%2C+t+%3D+0+..+2*PI\n          settings.shape = function shapeTriangle(theta) {\n            var thetaPrime = theta % (2 * Math.PI / 3);\n            return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));\n          };\n\n          break;\n\n        case 'triangle':\n        case 'triangle-upright':\n          settings.shape = function shapeTriangle(theta) {\n            var thetaPrime = (theta + Math.PI * 3 / 2) % (2 * Math.PI / 3);\n            return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));\n          };\n\n          break;\n\n        case 'pentagon':\n          settings.shape = function shapePentagon(theta) {\n            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 5);\n            return 1 / (Math.cos(thetaPrime) + 0.726543 * Math.sin(thetaPrime));\n          };\n\n          break;\n\n        case 'star':\n          settings.shape = function shapeStar(theta) {\n            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 10);\n\n            if ((theta + 0.955) % (2 * Math.PI / 5) - 2 * Math.PI / 10 >= 0) {\n              return 1 / (Math.cos(2 * Math.PI / 10 - thetaPrime) + 3.07768 * Math.sin(2 * Math.PI / 10 - thetaPrime));\n            } else {\n              return 1 / (Math.cos(thetaPrime) + 3.07768 * Math.sin(thetaPrime));\n            }\n          };\n\n          break;\n      }\n    }\n    /* Make sure gridSize is a whole number and is not smaller than 4px */\n\n\n    settings.gridSize = Math.max(Math.floor(settings.gridSize), 4);\n    /* shorthand */\n\n    var g = settings.gridSize;\n    var maskRectWidth = g - settings.maskGapWidth;\n    /* normalize rotation settings */\n\n    var rotationRange = Math.abs(settings.maxRotation - settings.minRotation);\n    var minRotation = Math.min(settings.maxRotation, settings.minRotation);\n    var rotationStep = settings.rotationStep;\n    /* information/object available to all functions, set when start() */\n\n    var grid, // 2d array containing filling information\n    ngx, ngy, // width and height of the grid\n    center, // position of the center of the cloud\n    maxRadius;\n    /* timestamp for measuring each putWord() action */\n\n    var escapeTime;\n    /* function for getting the color of the text */\n\n    var getTextColor;\n\n    function random_hsl_color(min, max) {\n      return 'hsl(' + (Math.random() * 360).toFixed() + ',' + (Math.random() * 30 + 70).toFixed() + '%,' + (Math.random() * (max - min) + min).toFixed() + '%)';\n    }\n\n    switch (settings.color) {\n      case 'random-dark':\n        getTextColor = function getRandomDarkColor() {\n          return random_hsl_color(10, 50);\n        };\n\n        break;\n\n      case 'random-light':\n        getTextColor = function getRandomLightColor() {\n          return random_hsl_color(50, 90);\n        };\n\n        break;\n\n      default:\n        if (typeof settings.color === 'function') {\n          getTextColor = settings.color;\n        }\n\n        break;\n    }\n    /* function for getting the classes of the text */\n\n\n    var getTextClasses = null;\n\n    if (typeof settings.classes === 'function') {\n      getTextClasses = settings.classes;\n    }\n    /* Interactive */\n\n\n    var interactive = false;\n    var infoGrid = [];\n    var hovered;\n\n    var getInfoGridFromMouseTouchEvent = function getInfoGridFromMouseTouchEvent(evt) {\n      var canvas = evt.currentTarget;\n      var rect = canvas.getBoundingClientRect();\n      var clientX;\n      var clientY;\n      /** Detect if touches are available */\n\n      if (evt.touches) {\n        clientX = evt.touches[0].clientX;\n        clientY = evt.touches[0].clientY;\n      } else {\n        clientX = evt.clientX;\n        clientY = evt.clientY;\n      }\n\n      var eventX = clientX - rect.left;\n      var eventY = clientY - rect.top;\n      var x = Math.floor(eventX * (canvas.width / rect.width || 1) / g);\n      var y = Math.floor(eventY * (canvas.height / rect.height || 1) / g);\n      return infoGrid[x][y];\n    };\n\n    var wordcloudhover = function wordcloudhover(evt) {\n      var info = getInfoGridFromMouseTouchEvent(evt);\n\n      if (hovered === info) {\n        return;\n      }\n\n      hovered = info;\n\n      if (!info) {\n        settings.hover(undefined, undefined, evt);\n        return;\n      }\n\n      settings.hover(info.item, info.dimension, evt);\n    };\n\n    var wordcloudclick = function wordcloudclick(evt) {\n      var info = getInfoGridFromMouseTouchEvent(evt);\n\n      if (!info) {\n        return;\n      }\n\n      settings.click(info.item, info.dimension, evt);\n      evt.preventDefault();\n    };\n    /* Get points on the grid for a given radius away from the center */\n\n\n    var pointsAtRadius = [];\n\n    var getPointsAtRadius = function getPointsAtRadius(radius) {\n      if (pointsAtRadius[radius]) {\n        return pointsAtRadius[radius];\n      } // Look for these number of points on each radius\n\n\n      var T = radius * 8; // Getting all the points at this radius\n\n      var t = T;\n      var points = [];\n\n      if (radius === 0) {\n        points.push([center[0], center[1], 0]);\n      }\n\n      while (t--) {\n        // distort the radius to put the cloud in shape\n        var rx = 1;\n\n        if (settings.shape !== 'circle') {\n          rx = settings.shape(t / T * 2 * Math.PI); // 0 to 1\n        } // Push [x, y, t]; t is used solely for getTextColor()\n\n\n        points.push([center[0] + radius * rx * Math.cos(-t / T * 2 * Math.PI), center[1] + radius * rx * Math.sin(-t / T * 2 * Math.PI) * settings.ellipticity, t / T * 2 * Math.PI]);\n      }\n\n      pointsAtRadius[radius] = points;\n      return points;\n    };\n    /* Return true if we had spent too much time */\n\n\n    var exceedTime = function exceedTime() {\n      return settings.abortThreshold > 0 && new Date().getTime() - escapeTime > settings.abortThreshold;\n    };\n    /* Get the deg of rotation according to settings, and luck. */\n\n\n    var getRotateDeg = function getRotateDeg() {\n      if (settings.rotateRatio === 0) {\n        return 0;\n      }\n\n      if (Math.random() > settings.rotateRatio) {\n        return 0;\n      }\n\n      if (rotationRange === 0) {\n        return minRotation;\n      }\n\n      return minRotation + Math.round(Math.random() * rotationRange / rotationStep) * rotationStep;\n    };\n\n    var getTextInfo = function getTextInfo(word, weight, rotateDeg) {\n      // calculate the acutal font size\n      // fontSize === 0 means weightFactor function wants the text skipped,\n      // and size < minSize means we cannot draw the text.\n      var debug = false;\n      var fontSize = settings.weightFactor(weight);\n\n      if (fontSize <= settings.minSize) {\n        return false;\n      } // Scale factor here is to make sure fillText is not limited by\n      // the minium font size set by browser.\n      // It will always be 1 or 2n.\n\n\n      var mu = 1;\n\n      if (fontSize < minFontSize) {\n        mu = function calculateScaleFactor() {\n          var mu = 2;\n\n          while (mu * fontSize < minFontSize) {\n            mu += 2;\n          }\n\n          return mu;\n        }();\n      }\n\n      var fcanvas = document.createElement('canvas');\n      var fctx = fcanvas.getContext('2d', {\n        willReadFrequently: true\n      });\n      fctx.font = settings.fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily; // Estimate the dimension of the text with measureText().\n\n      var fw = fctx.measureText(word).width / mu;\n      var fh = Math.max(fontSize * mu, fctx.measureText('m').width, fctx.measureText('\\uFF37').width) / mu; // Create a boundary box that is larger than our estimates,\n      // so text don't get cut of (it sill might)\n\n      var boxWidth = fw + fh * 2;\n      var boxHeight = fh * 3;\n      var fgw = Math.ceil(boxWidth / g);\n      var fgh = Math.ceil(boxHeight / g);\n      boxWidth = fgw * g;\n      boxHeight = fgh * g; // Calculate the proper offsets to make the text centered at\n      // the preferred position.\n      // This is simply half of the width.\n\n      var fillTextOffsetX = -fw / 2; // Instead of moving the box to the exact middle of the preferred\n      // position, for Y-offset we move 0.4 instead, so Latin alphabets look\n      // vertical centered.\n\n      var fillTextOffsetY = -fh * 0.4; // Calculate the actual dimension of the canvas, considering the rotation.\n\n      var cgh = Math.ceil((boxWidth * Math.abs(Math.sin(rotateDeg)) + boxHeight * Math.abs(Math.cos(rotateDeg))) / g);\n      var cgw = Math.ceil((boxWidth * Math.abs(Math.cos(rotateDeg)) + boxHeight * Math.abs(Math.sin(rotateDeg))) / g);\n      var width = cgw * g;\n      var height = cgh * g;\n      fcanvas.setAttribute('width', width);\n      fcanvas.setAttribute('height', height);\n\n      if (debug) {\n        // Attach fcanvas to the DOM\n        document.body.appendChild(fcanvas); // Save it's state so that we could restore and draw the grid correctly.\n\n        fctx.save();\n      } // Scale the canvas with |mu|.\n\n\n      fctx.scale(1 / mu, 1 / mu);\n      fctx.translate(width * mu / 2, height * mu / 2);\n      fctx.rotate(-rotateDeg); // Once the width/height is set, ctx info will be reset.\n      // Set it again here.\n\n      fctx.font = settings.fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily; // Fill the text into the fcanvas.\n      // XXX: We cannot because textBaseline = 'top' here because\n      // Firefox and Chrome uses different default line-height for canvas.\n      // Please read https://bugzil.la/737852#c6.\n      // Here, we use textBaseline = 'middle' and draw the text at exactly\n      // 0.5 * fontSize lower.\n\n      fctx.fillStyle = '#000';\n      fctx.textBaseline = 'middle';\n      fctx.fillText(word, fillTextOffsetX * mu, (fillTextOffsetY + fontSize * 0.5) * mu); // Get the pixels of the text\n\n      var imageData = fctx.getImageData(0, 0, width, height).data;\n\n      if (exceedTime()) {\n        return false;\n      }\n\n      if (debug) {\n        // Draw the box of the original estimation\n        fctx.strokeRect(fillTextOffsetX * mu, fillTextOffsetY, fw * mu, fh * mu);\n        fctx.restore();\n      } // Read the pixels and save the information to the occupied array\n\n\n      var occupied = [];\n      var gx = cgw,\n          gy,\n          x,\n          y;\n      var bounds = [cgh / 2, cgw / 2, cgh / 2, cgw / 2];\n\n      while (gx--) {\n        gy = cgh;\n\n        while (gy--) {\n          y = g;\n\n          singleGridLoop: {\n            while (y--) {\n              x = g;\n\n              while (x--) {\n                if (imageData[((gy * g + y) * width + (gx * g + x)) * 4 + 3]) {\n                  occupied.push([gx, gy]);\n\n                  if (gx < bounds[3]) {\n                    bounds[3] = gx;\n                  }\n\n                  if (gx > bounds[1]) {\n                    bounds[1] = gx;\n                  }\n\n                  if (gy < bounds[0]) {\n                    bounds[0] = gy;\n                  }\n\n                  if (gy > bounds[2]) {\n                    bounds[2] = gy;\n                  }\n\n                  if (debug) {\n                    fctx.fillStyle = 'rgba(255, 0, 0, 0.5)';\n                    fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n                  }\n\n                  break singleGridLoop;\n                }\n              }\n            }\n\n            if (debug) {\n              fctx.fillStyle = 'rgba(0, 0, 255, 0.5)';\n              fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n            }\n          }\n        }\n      }\n\n      if (debug) {\n        fctx.fillStyle = 'rgba(0, 255, 0, 0.5)';\n        fctx.fillRect(bounds[3] * g, bounds[0] * g, (bounds[1] - bounds[3] + 1) * g, (bounds[2] - bounds[0] + 1) * g);\n      } // Return information needed to create the text on the real canvas\n\n\n      return {\n        mu: mu,\n        occupied: occupied,\n        bounds: bounds,\n        gw: cgw,\n        gh: cgh,\n        fillTextOffsetX: fillTextOffsetX,\n        fillTextOffsetY: fillTextOffsetY,\n        fillTextWidth: fw,\n        fillTextHeight: fh,\n        fontSize: fontSize\n      };\n    };\n    /* Determine if there is room available in the given dimension */\n\n\n    var canFitText = function canFitText(gx, gy, gw, gh, occupied) {\n      // Go through the occupied points,\n      // return false if the space is not available.\n      var i = occupied.length;\n\n      while (i--) {\n        var px = gx + occupied[i][0];\n        var py = gy + occupied[i][1];\n\n        if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n          if (!settings.drawOutOfBound) {\n            return false;\n          }\n\n          continue;\n        }\n\n        if (!grid[px][py]) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n    /* Actually draw the text on the grid */\n\n\n    var drawText = function drawText(gx, gy, info, word, weight, distance, theta, rotateDeg, attributes) {\n      var fontSize = info.fontSize;\n      var color;\n\n      if (getTextColor) {\n        color = getTextColor(word, weight, fontSize, distance, theta);\n      } else {\n        color = settings.color;\n      }\n\n      var classes;\n\n      if (getTextClasses) {\n        classes = getTextClasses(word, weight, fontSize, distance, theta);\n      } else {\n        classes = settings.classes;\n      }\n\n      var dimension;\n      var bounds = info.bounds;\n      dimension = {\n        x: (gx + bounds[3]) * g,\n        y: (gy + bounds[0]) * g,\n        w: (bounds[1] - bounds[3] + 1) * g,\n        h: (bounds[2] - bounds[0] + 1) * g\n      };\n      elements.forEach(function (el) {\n        if (el.getContext) {\n          var ctx = el.getContext('2d');\n          var mu = info.mu; // Save the current state before messing it\n\n          ctx.save();\n          ctx.scale(1 / mu, 1 / mu);\n          ctx.font = settings.fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n          ctx.fillStyle = color; // Translate the canvas position to the origin coordinate of where\n          // the text should be put.\n\n          ctx.translate((gx + info.gw / 2) * g * mu, (gy + info.gh / 2) * g * mu);\n\n          if (rotateDeg !== 0) {\n            ctx.rotate(-rotateDeg);\n          } // Finally, fill the text.\n          // XXX: We cannot because textBaseline = 'top' here because\n          // Firefox and Chrome uses different default line-height for canvas.\n          // Please read https://bugzil.la/737852#c6.\n          // Here, we use textBaseline = 'middle' and draw the text at exactly\n          // 0.5 * fontSize lower.\n\n\n          ctx.textBaseline = 'middle';\n          ctx.fillText(word, info.fillTextOffsetX * mu, (info.fillTextOffsetY + fontSize * 0.5) * mu); // The below box is always matches how <span>s are positioned\n\n          /* ctx.strokeRect(info.fillTextOffsetX, info.fillTextOffsetY,\n            info.fillTextWidth, info.fillTextHeight); */\n          // Restore the state.\n\n          ctx.restore();\n        } else {\n          // drawText on DIV element\n          var span = document.createElement('span');\n          var transformRule = '';\n          transformRule = 'rotate(' + -rotateDeg / Math.PI * 180 + 'deg) ';\n\n          if (info.mu !== 1) {\n            transformRule += 'translateX(-' + info.fillTextWidth / 4 + 'px) ' + 'scale(' + 1 / info.mu + ')';\n          }\n\n          var styleRules = {\n            'position': 'absolute',\n            'display': 'block',\n            'font': settings.fontWeight + ' ' + fontSize * info.mu + 'px ' + settings.fontFamily,\n            'left': (gx + info.gw / 2) * g + info.fillTextOffsetX + 'px',\n            'top': (gy + info.gh / 2) * g + info.fillTextOffsetY + 'px',\n            'width': info.fillTextWidth + 'px',\n            'height': info.fillTextHeight + 'px',\n            'lineHeight': fontSize + 'px',\n            'whiteSpace': 'nowrap',\n            'transform': transformRule,\n            'webkitTransform': transformRule,\n            'msTransform': transformRule,\n            'transformOrigin': '50% 40%',\n            'webkitTransformOrigin': '50% 40%',\n            'msTransformOrigin': '50% 40%'\n          };\n\n          if (color) {\n            styleRules.color = color;\n          }\n\n          span.textContent = word;\n\n          for (var cssProp in styleRules) {\n            span.style[cssProp] = styleRules[cssProp];\n          }\n\n          if (attributes) {\n            for (var attribute in attributes) {\n              span.setAttribute(attribute, attributes[attribute]);\n            }\n          }\n\n          if (classes) {\n            span.className += classes;\n          }\n\n          el.appendChild(span);\n        }\n      });\n    };\n    /* Help function to updateGrid */\n\n\n    var fillGridAt = function fillGridAt(x, y, drawMask, dimension, item) {\n      if (x >= ngx || y >= ngy || x < 0 || y < 0) {\n        return;\n      }\n\n      grid[x][y] = false;\n\n      if (drawMask) {\n        var ctx = elements[0].getContext('2d');\n        ctx.fillRect(x * g, y * g, maskRectWidth, maskRectWidth);\n      }\n\n      if (interactive) {\n        infoGrid[x][y] = {\n          item: item,\n          dimension: dimension\n        };\n      }\n    };\n    /* Update the filling information of the given space with occupied points.\n       Draw the mask on the canvas if necessary. */\n\n\n    var updateGrid = function updateGrid(gx, gy, gw, gh, info, item) {\n      var occupied = info.occupied;\n      var drawMask = settings.drawMask;\n      var ctx;\n\n      if (drawMask) {\n        ctx = elements[0].getContext('2d');\n        ctx.save();\n        ctx.fillStyle = settings.maskColor;\n      }\n\n      var dimension;\n\n      if (interactive) {\n        var bounds = info.bounds;\n        dimension = {\n          x: (gx + bounds[3]) * g,\n          y: (gy + bounds[0]) * g,\n          w: (bounds[1] - bounds[3] + 1) * g,\n          h: (bounds[2] - bounds[0] + 1) * g\n        };\n      }\n\n      var i = occupied.length;\n\n      while (i--) {\n        var px = gx + occupied[i][0];\n        var py = gy + occupied[i][1];\n\n        if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n          continue;\n        }\n\n        fillGridAt(px, py, drawMask, dimension, item);\n      }\n\n      if (drawMask) {\n        ctx.restore();\n      }\n    };\n    /* putWord() processes each item on the list,\n       calculate it's size and determine it's position, and actually\n       put it on the canvas. */\n\n\n    var putWord = function putWord(item) {\n      var word, weight, attributes;\n\n      if (Array.isArray(item)) {\n        word = item[0];\n        weight = item[1];\n      } else {\n        word = item.word;\n        weight = item.weight;\n        attributes = item.attributes;\n      }\n\n      var rotateDeg = getRotateDeg(); // get info needed to put the text onto the canvas\n\n      var info = getTextInfo(word, weight, rotateDeg); // not getting the info means we shouldn't be drawing this one.\n\n      if (!info) {\n        return false;\n      }\n\n      if (exceedTime()) {\n        return false;\n      } // If drawOutOfBound is set to false,\n      // skip the loop if we have already know the bounding box of\n      // word is larger than the canvas.\n\n\n      if (!settings.drawOutOfBound) {\n        var bounds = info.bounds;\n\n        if (bounds[1] - bounds[3] + 1 > ngx || bounds[2] - bounds[0] + 1 > ngy) {\n          return false;\n        }\n      } // Determine the position to put the text by\n      // start looking for the nearest points\n\n\n      var r = maxRadius + 1;\n\n      var tryToPutWordAtPoint = function (gxy) {\n        var gx = Math.floor(gxy[0] - info.gw / 2);\n        var gy = Math.floor(gxy[1] - info.gh / 2);\n        var gw = info.gw;\n        var gh = info.gh; // If we cannot fit the text at this position, return false\n        // and go to the next position.\n\n        if (!canFitText(gx, gy, gw, gh, info.occupied)) {\n          return false;\n        } // Actually put the text on the canvas\n\n\n        drawText(gx, gy, info, word, weight, maxRadius - r, gxy[2], rotateDeg, attributes); // Mark the spaces on the grid as filled\n\n        updateGrid(gx, gy, gw, gh, info, item);\n        return {\n          gx: gx,\n          gy: gy,\n          rot: rotateDeg,\n          info: info\n        };\n      };\n\n      while (r--) {\n        var points = getPointsAtRadius(maxRadius - r);\n\n        if (settings.shuffle) {\n          points = [].concat(points);\n          shuffleArray(points);\n        } // Try to fit the words by looking at each point.\n        // array.some() will stop and return true\n        // when putWordAtPoint() returns true.\n\n\n        for (var i = 0; i < points.length; i++) {\n          var res = tryToPutWordAtPoint(points[i]);\n\n          if (res) {\n            return res;\n          }\n        } // var drawn = points.some(tryToPutWordAtPoint);\n        // if (drawn) {\n        //   // leave putWord() and return true\n        //   return true;\n        // }\n\n      } // we tried all distances but text won't fit, return null\n\n\n      return null;\n    };\n    /* Send DOM event to all elements. Will stop sending event and return\n       if the previous one is canceled (for cancelable events). */\n\n\n    var sendEvent = function sendEvent(type, cancelable, detail) {\n      if (cancelable) {\n        return !elements.some(function (el) {\n          var evt = document.createEvent('CustomEvent');\n          evt.initCustomEvent(type, true, cancelable, detail || {});\n          return !el.dispatchEvent(evt);\n        }, this);\n      } else {\n        elements.forEach(function (el) {\n          var evt = document.createEvent('CustomEvent');\n          evt.initCustomEvent(type, true, cancelable, detail || {});\n          el.dispatchEvent(evt);\n        }, this);\n      }\n    };\n    /* Start drawing on a canvas */\n\n\n    var start = function start() {\n      // For dimensions, clearCanvas etc.,\n      // we only care about the first element.\n      var canvas = elements[0];\n\n      if (canvas.getContext) {\n        ngx = Math.ceil(canvas.width / g);\n        ngy = Math.ceil(canvas.height / g);\n      } else {\n        var rect = canvas.getBoundingClientRect();\n        ngx = Math.ceil(rect.width / g);\n        ngy = Math.ceil(rect.height / g);\n      } // Sending a wordcloudstart event which cause the previous loop to stop.\n      // Do nothing if the event is canceled.\n\n\n      if (!sendEvent('wordcloudstart', true)) {\n        return;\n      } // Determine the center of the word cloud\n\n\n      center = settings.origin ? [settings.origin[0] / g, settings.origin[1] / g] : [ngx / 2, ngy / 2]; // Maxium radius to look for space\n\n      maxRadius = Math.floor(Math.sqrt(ngx * ngx + ngy * ngy));\n      /* Clear the canvas only if the clearCanvas is set,\n         if not, update the grid to the current canvas state */\n\n      grid = [];\n      var gx, gy, i;\n\n      if (!canvas.getContext || settings.clearCanvas) {\n        elements.forEach(function (el) {\n          if (el.getContext) {\n            var ctx = el.getContext('2d');\n            ctx.fillStyle = settings.backgroundColor;\n            ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n            ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n          } else {\n            el.textContent = '';\n            el.style.backgroundColor = settings.backgroundColor;\n            el.style.position = 'relative';\n          }\n        });\n        /* fill the grid with empty state */\n\n        gx = ngx;\n\n        while (gx--) {\n          grid[gx] = [];\n          gy = ngy;\n\n          while (gy--) {\n            grid[gx][gy] = true;\n          }\n        }\n      } else {\n        /* Determine bgPixel by creating\n           another canvas and fill the specified background color. */\n        var bctx = document.createElement('canvas').getContext('2d');\n        bctx.fillStyle = settings.backgroundColor;\n        bctx.fillRect(0, 0, 1, 1);\n        var bgPixel = bctx.getImageData(0, 0, 1, 1).data;\n        /* Read back the pixels of the canvas we got to tell which part of the\n           canvas is empty.\n           (no clearCanvas only works with a canvas, not divs) */\n\n        var imageData = canvas.getContext('2d').getImageData(0, 0, ngx * g, ngy * g).data;\n        gx = ngx;\n        var x, y;\n\n        while (gx--) {\n          grid[gx] = [];\n          gy = ngy;\n\n          while (gy--) {\n            y = g;\n\n            singleGridLoop: while (y--) {\n              x = g;\n\n              while (x--) {\n                i = 4;\n\n                while (i--) {\n                  if (imageData[((gy * g + y) * ngx * g + (gx * g + x)) * 4 + i] !== bgPixel[i]) {\n                    grid[gx][gy] = false;\n                    break singleGridLoop;\n                  }\n                }\n              }\n            }\n\n            if (grid[gx][gy] !== false) {\n              grid[gx][gy] = true;\n            }\n          }\n        }\n\n        imageData = bctx = bgPixel = undefined;\n      } // fill the infoGrid with empty state if we need it\n\n\n      if (settings.hover || settings.click) {\n        interactive = true;\n        /* fill the grid with empty state */\n\n        gx = ngx + 1;\n\n        while (gx--) {\n          infoGrid[gx] = [];\n        }\n\n        if (settings.hover) {\n          canvas.addEventListener('mousemove', wordcloudhover);\n        }\n\n        if (settings.click) {\n          canvas.addEventListener('click', wordcloudclick);\n          canvas.addEventListener('touchstart', wordcloudclick);\n          canvas.addEventListener('touchend', function (e) {\n            e.preventDefault();\n          });\n          canvas.style.webkitTapHighlightColor = 'rgba(0, 0, 0, 0)';\n        }\n\n        canvas.addEventListener('wordcloudstart', function stopInteraction() {\n          canvas.removeEventListener('wordcloudstart', stopInteraction);\n          canvas.removeEventListener('mousemove', wordcloudhover);\n          canvas.removeEventListener('click', wordcloudclick);\n          hovered = undefined;\n        });\n      }\n\n      i = 0;\n      var loopingFunction, stoppingFunction;\n\n      if (settings.wait !== 0) {\n        loopingFunction = window.setTimeout;\n        stoppingFunction = window.clearTimeout;\n      } else {\n        loopingFunction = window.setImmediate;\n        stoppingFunction = window.clearImmediate;\n      }\n\n      var addEventListener = function addEventListener(type, listener) {\n        elements.forEach(function (el) {\n          el.addEventListener(type, listener);\n        }, this);\n      };\n\n      var removeEventListener = function removeEventListener(type, listener) {\n        elements.forEach(function (el) {\n          el.removeEventListener(type, listener);\n        }, this);\n      };\n\n      var anotherWordCloudStart = function anotherWordCloudStart() {\n        removeEventListener('wordcloudstart', anotherWordCloudStart);\n        stoppingFunction(timer);\n      };\n\n      addEventListener('wordcloudstart', anotherWordCloudStart);\n      var timer = loopingFunction(function loop() {\n        if (i >= settings.list.length) {\n          stoppingFunction(timer);\n          sendEvent('wordcloudstop', false);\n          removeEventListener('wordcloudstart', anotherWordCloudStart);\n          return;\n        }\n\n        escapeTime = new Date().getTime();\n        var drawn = putWord(settings.list[i]);\n        var canceled = !sendEvent('wordclouddrawn', true, {\n          item: settings.list[i],\n          drawn: drawn\n        });\n\n        if (exceedTime() || canceled) {\n          stoppingFunction(timer);\n          settings.abort();\n          sendEvent('wordcloudabort', false);\n          sendEvent('wordcloudstop', false);\n          removeEventListener('wordcloudstart', anotherWordCloudStart);\n          return;\n        }\n\n        i++;\n        timer = loopingFunction(loop, settings.wait);\n      }, settings.wait);\n    }; // All set, start the drawing\n\n\n    start();\n  };\n\n  WordCloud.isSupported = isSupported;\n  WordCloud.minFontSize = minFontSize; // Expose the library as an AMD module\n\n  if (typeof define === 'function' && define.amd) {\n    define('wordcloud', [], function () {\n      return WordCloud;\n    });\n  } else if (typeof module !== 'undefined' && module.exports) {\n    module.exports = WordCloud;\n  } else {\n    global.WordCloud = WordCloud;\n  }\n})(this); //jshint ignore:line","map":{"version":3,"names":["window","setImmediate","setupSetImmediate","msSetImmediate","webkitSetImmediate","mozSetImmediate","oSetImmediate","setupSetZeroTimeout","postMessage","addEventListener","callbacks","undefined","message","setZeroTimeout","callback","id","length","push","toString","setZeroTimeoutMessage","evt","data","substr","stopImmediatePropagation","parseInt","clearImmediate","clearZeroTimeout","setImmediateFallback","fn","setTimeout","setupClearImmediate","msClearImmediate","webkitClearImmediate","mozClearImmediate","oClearImmediate","clearImmediateFallback","timer","clearTimeout","global","isSupported","canvas","document","createElement","getContext","ctx","getImageData","fillText","Array","prototype","some","minFontSize","getMinFontSize","size","hanWidth","mWidth","font","measureText","width","shuffleArray","arr","j","x","i","Math","floor","random","WordCloud","elements","options","isArray","forEach","el","getElementById","tagName","appendChild","settings","list","fontFamily","fontWeight","color","minSize","weightFactor","clearCanvas","backgroundColor","gridSize","drawOutOfBound","origin","drawMask","maskColor","maskGapWidth","wait","abortThreshold","abort","noop","minRotation","PI","maxRotation","rotationStep","shuffle","rotateRatio","shape","ellipticity","classes","hover","click","key","factor","pt","shapeCardioid","theta","sin","shapeSquare","thetaPrime","cos","shapeTriangle","sqrt","shapePentagon","shapeStar","max","g","maskRectWidth","rotationRange","abs","min","grid","ngx","ngy","center","maxRadius","escapeTime","getTextColor","random_hsl_color","toFixed","getRandomDarkColor","getRandomLightColor","getTextClasses","interactive","infoGrid","hovered","getInfoGridFromMouseTouchEvent","currentTarget","rect","getBoundingClientRect","clientX","clientY","touches","eventX","left","eventY","top","y","height","wordcloudhover","info","item","dimension","wordcloudclick","preventDefault","pointsAtRadius","getPointsAtRadius","radius","T","t","points","rx","exceedTime","Date","getTime","getRotateDeg","round","getTextInfo","word","weight","rotateDeg","debug","fontSize","mu","calculateScaleFactor","fcanvas","fctx","willReadFrequently","fw","fh","boxWidth","boxHeight","fgw","ceil","fgh","fillTextOffsetX","fillTextOffsetY","cgh","cgw","setAttribute","body","save","scale","translate","rotate","fillStyle","textBaseline","imageData","strokeRect","restore","occupied","gx","gy","bounds","singleGridLoop","fillRect","gw","gh","fillTextWidth","fillTextHeight","canFitText","px","py","drawText","distance","attributes","w","h","span","transformRule","styleRules","textContent","cssProp","style","attribute","className","fillGridAt","updateGrid","putWord","r","tryToPutWordAtPoint","gxy","rot","concat","res","sendEvent","type","cancelable","detail","createEvent","initCustomEvent","dispatchEvent","start","clearRect","position","bctx","bgPixel","e","webkitTapHighlightColor","stopInteraction","removeEventListener","loopingFunction","stoppingFunction","listener","anotherWordCloudStart","loop","drawn","canceled","define","amd","module","exports"],"sources":["D:/vue/Mao/node_modules/echarts-wordcloud/src/layout.js"],"sourcesContent":["/*!\n * wordcloud2.js\n * http://timdream.org/wordcloud2.js/\n *\n * Copyright 2011 - 2013 Tim Chien\n * Released under the MIT license\n */\n\n'use strict';\n\n// setImmediate\nif (!window.setImmediate) {\n  window.setImmediate = (function setupSetImmediate() {\n    return window.msSetImmediate ||\n    window.webkitSetImmediate ||\n    window.mozSetImmediate ||\n    window.oSetImmediate ||\n    (function setupSetZeroTimeout() {\n      if (!window.postMessage || !window.addEventListener) {\n        return null;\n      }\n\n      var callbacks = [undefined];\n      var message = 'zero-timeout-message';\n\n      // Like setTimeout, but only takes a function argument.  There's\n      // no time argument (always zero) and no arguments (you have to\n      // use a closure).\n      var setZeroTimeout = function setZeroTimeout(callback) {\n        var id = callbacks.length;\n        callbacks.push(callback);\n        window.postMessage(message + id.toString(36), '*');\n\n        return id;\n      };\n\n      window.addEventListener('message', function setZeroTimeoutMessage(evt) {\n        // Skipping checking event source, retarded IE confused this window\n        // object with another in the presence of iframe\n        if (typeof evt.data !== 'string' ||\n            evt.data.substr(0, message.length) !== message/* ||\n            evt.source !== window */) {\n          return;\n        }\n\n        evt.stopImmediatePropagation();\n\n        var id = parseInt(evt.data.substr(message.length), 36);\n        if (!callbacks[id]) {\n          return;\n        }\n\n        callbacks[id]();\n        callbacks[id] = undefined;\n      }, true);\n\n      /* specify clearImmediate() here since we need the scope */\n      window.clearImmediate = function clearZeroTimeout(id) {\n        if (!callbacks[id]) {\n          return;\n        }\n\n        callbacks[id] = undefined;\n      };\n\n      return setZeroTimeout;\n    })() ||\n    // fallback\n    function setImmediateFallback(fn) {\n      window.setTimeout(fn, 0);\n    };\n  })();\n}\n\nif (!window.clearImmediate) {\n  window.clearImmediate = (function setupClearImmediate() {\n    return window.msClearImmediate ||\n    window.webkitClearImmediate ||\n    window.mozClearImmediate ||\n    window.oClearImmediate ||\n    // \"clearZeroTimeout\" is implement on the previous block ||\n    // fallback\n    function clearImmediateFallback(timer) {\n      window.clearTimeout(timer);\n    };\n  })();\n}\n\n(function(global) {\n\n  // Check if WordCloud can run on this browser\n  var isSupported = (function isSupported() {\n    var canvas = document.createElement('canvas');\n    if (!canvas || !canvas.getContext) {\n      return false;\n    }\n\n    var ctx = canvas.getContext('2d');\n    if (!ctx.getImageData) {\n      return false;\n    }\n    if (!ctx.fillText) {\n      return false;\n    }\n\n    if (!Array.prototype.some) {\n      return false;\n    }\n    if (!Array.prototype.push) {\n      return false;\n    }\n\n    return true;\n  }());\n\n  // Find out if the browser impose minium font size by\n  // drawing small texts on a canvas and measure it's width.\n  var minFontSize = (function getMinFontSize() {\n    if (!isSupported) {\n      return;\n    }\n\n    var ctx = document.createElement('canvas').getContext('2d');\n\n    // start from 20\n    var size = 20;\n\n    // two sizes to measure\n    var hanWidth, mWidth;\n\n    while (size) {\n      ctx.font = size.toString(10) + 'px sans-serif';\n      if ((ctx.measureText('\\uFF37').width === hanWidth) &&\n          (ctx.measureText('m').width) === mWidth) {\n        return (size + 1);\n      }\n\n      hanWidth = ctx.measureText('\\uFF37').width;\n      mWidth = ctx.measureText('m').width;\n\n      size--;\n    }\n\n    return 0;\n  })();\n\n  // Based on http://jsfromhell.com/array/shuffle\n  var shuffleArray = function shuffleArray(arr) {\n    for (var j, x, i = arr.length; i;\n      j = Math.floor(Math.random() * i),\n      x = arr[--i], arr[i] = arr[j],\n      arr[j] = x) {}\n    return arr;\n  };\n\n  var WordCloud = function WordCloud(elements, options) {\n    if (!isSupported) {\n      return;\n    }\n\n    if (!Array.isArray(elements)) {\n      elements = [elements];\n    }\n\n    elements.forEach(function(el, i) {\n      if (typeof el === 'string') {\n        elements[i] = document.getElementById(el);\n        if (!elements[i]) {\n          throw 'The element id specified is not found.';\n        }\n      } else if (!el.tagName && !el.appendChild) {\n        throw 'You must pass valid HTML elements, or ID of the element.';\n      }\n    });\n\n    /* Default values to be overwritten by options object */\n    var settings = {\n      list: [],\n      fontFamily: '\"Trebuchet MS\", \"Heiti TC\", \"微軟正黑體\", ' +\n                  '\"Arial Unicode MS\", \"Droid Fallback Sans\", sans-serif',\n      fontWeight: 'normal',\n      color: 'random-dark',\n      minSize: 0, // 0 to disable\n      weightFactor: 1,\n      clearCanvas: true,\n      backgroundColor: '#fff',  // opaque white = rgba(255, 255, 255, 1)\n\n      gridSize: 8,\n      drawOutOfBound: false,\n      origin: null,\n\n      drawMask: false,\n      maskColor: 'rgba(255,0,0,0.3)',\n      maskGapWidth: 0.3,\n\n      wait: 0,\n      abortThreshold: 0, // disabled\n      abort: function noop() {},\n\n      minRotation: - Math.PI / 2,\n      maxRotation: Math.PI / 2,\n      rotationStep: 0.1,\n\n      shuffle: true,\n      rotateRatio: 0.1,\n\n      shape: 'circle',\n      ellipticity: 0.65,\n\n      classes: null,\n\n      hover: null,\n      click: null\n    };\n\n    if (options) {\n      for (var key in options) {\n        if (key in settings) {\n          settings[key] = options[key];\n        }\n      }\n    }\n\n    /* Convert weightFactor into a function */\n    if (typeof settings.weightFactor !== 'function') {\n      var factor = settings.weightFactor;\n      settings.weightFactor = function weightFactor(pt) {\n        return pt * factor; //in px\n      };\n    }\n\n    /* Convert shape into a function */\n    if (typeof settings.shape !== 'function') {\n      switch (settings.shape) {\n        case 'circle':\n        /* falls through */\n        default:\n          // 'circle' is the default and a shortcut in the code loop.\n          settings.shape = 'circle';\n          break;\n\n        case 'cardioid':\n          settings.shape = function shapeCardioid(theta) {\n            return 1 - Math.sin(theta);\n          };\n          break;\n\n        /*\n        To work out an X-gon, one has to calculate \"m\",\n        where 1/(cos(2*PI/X)+m*sin(2*PI/X)) = 1/(cos(0)+m*sin(0))\n        http://www.wolframalpha.com/input/?i=1%2F%28cos%282*PI%2FX%29%2Bm*sin%28\n        2*PI%2FX%29%29+%3D+1%2F%28cos%280%29%2Bm*sin%280%29%29\n        Copy the solution into polar equation r = 1/(cos(t') + m*sin(t'))\n        where t' equals to mod(t, 2PI/X);\n        */\n\n        case 'diamond':\n        case 'square':\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n          // %28t%2C+PI%2F2%29%29%2Bsin%28mod+%28t%2C+PI%2F2%29%29%29%2C+t+%3D\n          // +0+..+2*PI\n          settings.shape = function shapeSquare(theta) {\n            var thetaPrime = theta % (2 * Math.PI / 4);\n            return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));\n          };\n          break;\n\n        case 'triangle-forward':\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n          // %28t%2C+2*PI%2F3%29%29%2Bsqrt%283%29sin%28mod+%28t%2C+2*PI%2F3%29\n          // %29%29%2C+t+%3D+0+..+2*PI\n          settings.shape = function shapeTriangle(theta) {\n            var thetaPrime = theta % (2 * Math.PI / 3);\n            return 1 / (Math.cos(thetaPrime) +\n                        Math.sqrt(3) * Math.sin(thetaPrime));\n          };\n          break;\n\n        case 'triangle':\n        case 'triangle-upright':\n          settings.shape = function shapeTriangle(theta) {\n            var thetaPrime = (theta + Math.PI * 3 / 2) % (2 * Math.PI / 3);\n            return 1 / (Math.cos(thetaPrime) +\n                        Math.sqrt(3) * Math.sin(thetaPrime));\n          };\n          break;\n\n        case 'pentagon':\n          settings.shape = function shapePentagon(theta) {\n            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 5);\n            return 1 / (Math.cos(thetaPrime) +\n                        0.726543 * Math.sin(thetaPrime));\n          };\n          break;\n\n        case 'star':\n          settings.shape = function shapeStar(theta) {\n            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 10);\n            if ((theta + 0.955) % (2 * Math.PI / 5) - (2 * Math.PI / 10) >= 0) {\n              return 1 / (Math.cos((2 * Math.PI / 10) - thetaPrime) +\n                          3.07768 * Math.sin((2 * Math.PI / 10) - thetaPrime));\n            } else {\n              return 1 / (Math.cos(thetaPrime) +\n                          3.07768 * Math.sin(thetaPrime));\n            }\n          };\n          break;\n      }\n    }\n\n    /* Make sure gridSize is a whole number and is not smaller than 4px */\n    settings.gridSize = Math.max(Math.floor(settings.gridSize), 4);\n\n    /* shorthand */\n    var g = settings.gridSize;\n    var maskRectWidth = g - settings.maskGapWidth;\n\n    /* normalize rotation settings */\n    var rotationRange = Math.abs(settings.maxRotation - settings.minRotation);\n    var minRotation = Math.min(settings.maxRotation, settings.minRotation);\n    var rotationStep = settings.rotationStep;\n\n    /* information/object available to all functions, set when start() */\n    var grid, // 2d array containing filling information\n      ngx, ngy, // width and height of the grid\n      center, // position of the center of the cloud\n      maxRadius;\n\n    /* timestamp for measuring each putWord() action */\n    var escapeTime;\n\n    /* function for getting the color of the text */\n    var getTextColor;\n    function random_hsl_color(min, max) {\n      return 'hsl(' +\n        (Math.random() * 360).toFixed() + ',' +\n        (Math.random() * 30 + 70).toFixed() + '%,' +\n        (Math.random() * (max - min) + min).toFixed() + '%)';\n    }\n    switch (settings.color) {\n      case 'random-dark':\n        getTextColor = function getRandomDarkColor() {\n          return random_hsl_color(10, 50);\n        };\n        break;\n\n      case 'random-light':\n        getTextColor = function getRandomLightColor() {\n          return random_hsl_color(50, 90);\n        };\n        break;\n\n      default:\n        if (typeof settings.color === 'function') {\n          getTextColor = settings.color;\n        }\n        break;\n    }\n\n    /* function for getting the classes of the text */\n    var getTextClasses = null;\n    if (typeof settings.classes === 'function') {\n      getTextClasses = settings.classes;\n    }\n\n    /* Interactive */\n    var interactive = false;\n    var infoGrid = [];\n    var hovered;\n\n    var getInfoGridFromMouseTouchEvent =\n    function getInfoGridFromMouseTouchEvent(evt) {\n      var canvas = evt.currentTarget;\n      var rect = canvas.getBoundingClientRect();\n      var clientX;\n      var clientY;\n      /** Detect if touches are available */\n      if (evt.touches) {\n        clientX = evt.touches[0].clientX;\n        clientY = evt.touches[0].clientY;\n      } else {\n        clientX = evt.clientX;\n        clientY = evt.clientY;\n      }\n      var eventX = clientX - rect.left;\n      var eventY = clientY - rect.top;\n\n      var x = Math.floor(eventX * ((canvas.width / rect.width) || 1) / g);\n      var y = Math.floor(eventY * ((canvas.height / rect.height) || 1) / g);\n\n      return infoGrid[x][y];\n    };\n\n    var wordcloudhover = function wordcloudhover(evt) {\n      var info = getInfoGridFromMouseTouchEvent(evt);\n\n      if (hovered === info) {\n        return;\n      }\n\n      hovered = info;\n      if (!info) {\n        settings.hover(undefined, undefined, evt);\n\n        return;\n      }\n\n      settings.hover(info.item, info.dimension, evt);\n\n    };\n\n    var wordcloudclick = function wordcloudclick(evt) {\n      var info = getInfoGridFromMouseTouchEvent(evt);\n      if (!info) {\n        return;\n      }\n\n      settings.click(info.item, info.dimension, evt);\n      evt.preventDefault();\n    };\n\n    /* Get points on the grid for a given radius away from the center */\n    var pointsAtRadius = [];\n    var getPointsAtRadius = function getPointsAtRadius(radius) {\n      if (pointsAtRadius[radius]) {\n        return pointsAtRadius[radius];\n      }\n\n      // Look for these number of points on each radius\n      var T = radius * 8;\n\n      // Getting all the points at this radius\n      var t = T;\n      var points = [];\n\n      if (radius === 0) {\n        points.push([center[0], center[1], 0]);\n      }\n\n      while (t--) {\n        // distort the radius to put the cloud in shape\n        var rx = 1;\n        if (settings.shape !== 'circle') {\n          rx = settings.shape(t / T * 2 * Math.PI); // 0 to 1\n        }\n\n        // Push [x, y, t]; t is used solely for getTextColor()\n        points.push([\n          center[0] + radius * rx * Math.cos(-t / T * 2 * Math.PI),\n          center[1] + radius * rx * Math.sin(-t / T * 2 * Math.PI) *\n            settings.ellipticity,\n          t / T * 2 * Math.PI]);\n      }\n\n      pointsAtRadius[radius] = points;\n      return points;\n    };\n\n    /* Return true if we had spent too much time */\n    var exceedTime = function exceedTime() {\n      return ((settings.abortThreshold > 0) &&\n        ((new Date()).getTime() - escapeTime > settings.abortThreshold));\n    };\n\n    /* Get the deg of rotation according to settings, and luck. */\n    var getRotateDeg = function getRotateDeg() {\n      if (settings.rotateRatio === 0) {\n        return 0;\n      }\n\n      if (Math.random() > settings.rotateRatio) {\n        return 0;\n      }\n\n      if (rotationRange === 0) {\n        return minRotation;\n      }\n\n      return minRotation + Math.round(Math.random() * rotationRange / rotationStep) * rotationStep;\n    };\n\n    var getTextInfo = function getTextInfo(word, weight, rotateDeg) {\n      // calculate the acutal font size\n      // fontSize === 0 means weightFactor function wants the text skipped,\n      // and size < minSize means we cannot draw the text.\n      var debug = false;\n      var fontSize = settings.weightFactor(weight);\n      if (fontSize <= settings.minSize) {\n        return false;\n      }\n\n      // Scale factor here is to make sure fillText is not limited by\n      // the minium font size set by browser.\n      // It will always be 1 or 2n.\n      var mu = 1;\n      if (fontSize < minFontSize) {\n        mu = (function calculateScaleFactor() {\n          var mu = 2;\n          while (mu * fontSize < minFontSize) {\n            mu += 2;\n          }\n          return mu;\n        })();\n      }\n\n      var fcanvas = document.createElement('canvas');\n      var fctx = fcanvas.getContext('2d', { willReadFrequently: true });\n\n      fctx.font = settings.fontWeight + ' ' +\n        (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n\n      // Estimate the dimension of the text with measureText().\n      var fw = fctx.measureText(word).width / mu;\n      var fh = Math.max(fontSize * mu,\n                        fctx.measureText('m').width,\n                        fctx.measureText('\\uFF37').width) / mu;\n\n      // Create a boundary box that is larger than our estimates,\n      // so text don't get cut of (it sill might)\n      var boxWidth = fw + fh * 2;\n      var boxHeight = fh * 3;\n      var fgw = Math.ceil(boxWidth / g);\n      var fgh = Math.ceil(boxHeight / g);\n      boxWidth = fgw * g;\n      boxHeight = fgh * g;\n\n      // Calculate the proper offsets to make the text centered at\n      // the preferred position.\n\n      // This is simply half of the width.\n      var fillTextOffsetX = - fw / 2;\n      // Instead of moving the box to the exact middle of the preferred\n      // position, for Y-offset we move 0.4 instead, so Latin alphabets look\n      // vertical centered.\n      var fillTextOffsetY = - fh * 0.4;\n\n      // Calculate the actual dimension of the canvas, considering the rotation.\n      var cgh = Math.ceil((boxWidth * Math.abs(Math.sin(rotateDeg)) +\n                           boxHeight * Math.abs(Math.cos(rotateDeg))) / g);\n      var cgw = Math.ceil((boxWidth * Math.abs(Math.cos(rotateDeg)) +\n                           boxHeight * Math.abs(Math.sin(rotateDeg))) / g);\n      var width = cgw * g;\n      var height = cgh * g;\n\n      fcanvas.setAttribute('width', width);\n      fcanvas.setAttribute('height', height);\n\n      if (debug) {\n        // Attach fcanvas to the DOM\n        document.body.appendChild(fcanvas);\n        // Save it's state so that we could restore and draw the grid correctly.\n        fctx.save();\n      }\n\n      // Scale the canvas with |mu|.\n      fctx.scale(1 / mu, 1 / mu);\n      fctx.translate(width * mu / 2, height * mu / 2);\n      fctx.rotate(- rotateDeg);\n\n      // Once the width/height is set, ctx info will be reset.\n      // Set it again here.\n      fctx.font = settings.fontWeight + ' ' +\n        (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n\n      // Fill the text into the fcanvas.\n      // XXX: We cannot because textBaseline = 'top' here because\n      // Firefox and Chrome uses different default line-height for canvas.\n      // Please read https://bugzil.la/737852#c6.\n      // Here, we use textBaseline = 'middle' and draw the text at exactly\n      // 0.5 * fontSize lower.\n      fctx.fillStyle = '#000';\n      fctx.textBaseline = 'middle';\n      fctx.fillText(word, fillTextOffsetX * mu,\n                    (fillTextOffsetY + fontSize * 0.5) * mu);\n\n      // Get the pixels of the text\n      var imageData = fctx.getImageData(0, 0, width, height).data;\n\n      if (exceedTime()) {\n        return false;\n      }\n\n      if (debug) {\n        // Draw the box of the original estimation\n        fctx.strokeRect(fillTextOffsetX * mu,\n                        fillTextOffsetY, fw * mu, fh * mu);\n        fctx.restore();\n      }\n\n      // Read the pixels and save the information to the occupied array\n      var occupied = [];\n      var gx = cgw, gy, x, y;\n      var bounds = [cgh / 2, cgw / 2, cgh / 2, cgw / 2];\n      while (gx--) {\n        gy = cgh;\n        while (gy--) {\n          y = g;\n          singleGridLoop: {\n            while (y--) {\n              x = g;\n              while (x--) {\n                if (imageData[((gy * g + y) * width +\n                               (gx * g + x)) * 4 + 3]) {\n                  occupied.push([gx, gy]);\n\n                  if (gx < bounds[3]) {\n                    bounds[3] = gx;\n                  }\n                  if (gx > bounds[1]) {\n                    bounds[1] = gx;\n                  }\n                  if (gy < bounds[0]) {\n                    bounds[0] = gy;\n                  }\n                  if (gy > bounds[2]) {\n                    bounds[2] = gy;\n                  }\n\n                  if (debug) {\n                    fctx.fillStyle = 'rgba(255, 0, 0, 0.5)';\n                    fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n                  }\n                  break singleGridLoop;\n                }\n              }\n            }\n            if (debug) {\n              fctx.fillStyle = 'rgba(0, 0, 255, 0.5)';\n              fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n            }\n          }\n        }\n      }\n\n      if (debug) {\n        fctx.fillStyle = 'rgba(0, 255, 0, 0.5)';\n        fctx.fillRect(bounds[3] * g,\n                      bounds[0] * g,\n                      (bounds[1] - bounds[3] + 1) * g,\n                      (bounds[2] - bounds[0] + 1) * g);\n      }\n\n      // Return information needed to create the text on the real canvas\n      return {\n        mu: mu,\n        occupied: occupied,\n        bounds: bounds,\n        gw: cgw,\n        gh: cgh,\n        fillTextOffsetX: fillTextOffsetX,\n        fillTextOffsetY: fillTextOffsetY,\n        fillTextWidth: fw,\n        fillTextHeight: fh,\n        fontSize: fontSize\n      };\n    };\n\n    /* Determine if there is room available in the given dimension */\n    var canFitText = function canFitText(gx, gy, gw, gh, occupied) {\n      // Go through the occupied points,\n      // return false if the space is not available.\n      var i = occupied.length;\n      while (i--) {\n        var px = gx + occupied[i][0];\n        var py = gy + occupied[i][1];\n\n        if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n          if (!settings.drawOutOfBound) {\n            return false;\n          }\n          continue;\n        }\n\n        if (!grid[px][py]) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    /* Actually draw the text on the grid */\n    var drawText = function drawText(gx, gy, info, word, weight,\n                                     distance, theta, rotateDeg, attributes) {\n\n      var fontSize = info.fontSize;\n      var color;\n      if (getTextColor) {\n        color = getTextColor(word, weight, fontSize, distance, theta);\n      } else {\n        color = settings.color;\n      }\n\n      var classes;\n      if (getTextClasses) {\n        classes = getTextClasses(word, weight, fontSize, distance, theta);\n      } else {\n        classes = settings.classes;\n      }\n\n      var dimension;\n      var bounds = info.bounds;\n      dimension = {\n        x: (gx + bounds[3]) * g,\n        y: (gy + bounds[0]) * g,\n        w: (bounds[1] - bounds[3] + 1) * g,\n        h: (bounds[2] - bounds[0] + 1) * g\n      };\n\n      elements.forEach(function(el) {\n        if (el.getContext) {\n          var ctx = el.getContext('2d');\n          var mu = info.mu;\n\n          // Save the current state before messing it\n          ctx.save();\n          ctx.scale(1 / mu, 1 / mu);\n\n          ctx.font = settings.fontWeight + ' ' +\n                     (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n          ctx.fillStyle = color;\n\n          // Translate the canvas position to the origin coordinate of where\n          // the text should be put.\n          ctx.translate((gx + info.gw / 2) * g * mu,\n                        (gy + info.gh / 2) * g * mu);\n\n          if (rotateDeg !== 0) {\n            ctx.rotate(- rotateDeg);\n          }\n\n          // Finally, fill the text.\n\n          // XXX: We cannot because textBaseline = 'top' here because\n          // Firefox and Chrome uses different default line-height for canvas.\n          // Please read https://bugzil.la/737852#c6.\n          // Here, we use textBaseline = 'middle' and draw the text at exactly\n          // 0.5 * fontSize lower.\n          ctx.textBaseline = 'middle';\n          ctx.fillText(word, info.fillTextOffsetX * mu,\n                             (info.fillTextOffsetY + fontSize * 0.5) * mu);\n\n          // The below box is always matches how <span>s are positioned\n          /* ctx.strokeRect(info.fillTextOffsetX, info.fillTextOffsetY,\n            info.fillTextWidth, info.fillTextHeight); */\n\n          // Restore the state.\n          ctx.restore();\n        } else {\n          // drawText on DIV element\n          var span = document.createElement('span');\n          var transformRule = '';\n          transformRule = 'rotate(' + (- rotateDeg / Math.PI * 180) + 'deg) ';\n          if (info.mu !== 1) {\n            transformRule +=\n              'translateX(-' + (info.fillTextWidth / 4) + 'px) ' +\n              'scale(' + (1 / info.mu) + ')';\n          }\n          var styleRules = {\n            'position': 'absolute',\n            'display': 'block',\n            'font': settings.fontWeight + ' ' +\n                    (fontSize * info.mu) + 'px ' + settings.fontFamily,\n            'left': ((gx + info.gw / 2) * g + info.fillTextOffsetX) + 'px',\n            'top': ((gy + info.gh / 2) * g + info.fillTextOffsetY) + 'px',\n            'width': info.fillTextWidth + 'px',\n            'height': info.fillTextHeight + 'px',\n            'lineHeight': fontSize + 'px',\n            'whiteSpace': 'nowrap',\n            'transform': transformRule,\n            'webkitTransform': transformRule,\n            'msTransform': transformRule,\n            'transformOrigin': '50% 40%',\n            'webkitTransformOrigin': '50% 40%',\n            'msTransformOrigin': '50% 40%'\n          };\n          if (color) {\n            styleRules.color = color;\n          }\n          span.textContent = word;\n          for (var cssProp in styleRules) {\n            span.style[cssProp] = styleRules[cssProp];\n          }\n          if (attributes) {\n            for (var attribute in attributes) {\n              span.setAttribute(attribute, attributes[attribute]);\n            }\n          }\n          if (classes) {\n            span.className += classes;\n          }\n          el.appendChild(span);\n        }\n      });\n    };\n\n    /* Help function to updateGrid */\n    var fillGridAt = function fillGridAt(x, y, drawMask, dimension, item) {\n      if (x >= ngx || y >= ngy || x < 0 || y < 0) {\n        return;\n      }\n\n      grid[x][y] = false;\n\n      if (drawMask) {\n        var ctx = elements[0].getContext('2d');\n        ctx.fillRect(x * g, y * g, maskRectWidth, maskRectWidth);\n      }\n\n      if (interactive) {\n        infoGrid[x][y] = { item: item, dimension: dimension };\n      }\n    };\n\n    /* Update the filling information of the given space with occupied points.\n       Draw the mask on the canvas if necessary. */\n    var updateGrid = function updateGrid(gx, gy, gw, gh, info, item) {\n      var occupied = info.occupied;\n      var drawMask = settings.drawMask;\n      var ctx;\n      if (drawMask) {\n        ctx = elements[0].getContext('2d');\n        ctx.save();\n        ctx.fillStyle = settings.maskColor;\n      }\n\n      var dimension;\n      if (interactive) {\n        var bounds = info.bounds;\n        dimension = {\n          x: (gx + bounds[3]) * g,\n          y: (gy + bounds[0]) * g,\n          w: (bounds[1] - bounds[3] + 1) * g,\n          h: (bounds[2] - bounds[0] + 1) * g\n        };\n      }\n\n      var i = occupied.length;\n      while (i--) {\n        var px = gx + occupied[i][0];\n        var py = gy + occupied[i][1];\n\n        if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n          continue;\n        }\n\n        fillGridAt(px, py, drawMask, dimension, item);\n      }\n\n      if (drawMask) {\n        ctx.restore();\n      }\n    };\n\n    /* putWord() processes each item on the list,\n       calculate it's size and determine it's position, and actually\n       put it on the canvas. */\n    var putWord = function putWord(item) {\n      var word, weight, attributes;\n      if (Array.isArray(item)) {\n        word = item[0];\n        weight = item[1];\n      } else {\n        word = item.word;\n        weight = item.weight;\n        attributes = item.attributes;\n      }\n      var rotateDeg = getRotateDeg();\n\n      // get info needed to put the text onto the canvas\n      var info = getTextInfo(word, weight, rotateDeg);\n\n      // not getting the info means we shouldn't be drawing this one.\n      if (!info) {\n        return false;\n      }\n\n      if (exceedTime()) {\n        return false;\n      }\n\n      // If drawOutOfBound is set to false,\n      // skip the loop if we have already know the bounding box of\n      // word is larger than the canvas.\n      if (!settings.drawOutOfBound) {\n        var bounds = info.bounds;\n        if ((bounds[1] - bounds[3] + 1) > ngx ||\n          (bounds[2] - bounds[0] + 1) > ngy) {\n          return false;\n        }\n      }\n\n      // Determine the position to put the text by\n      // start looking for the nearest points\n      var r = maxRadius + 1;\n\n      var tryToPutWordAtPoint = function(gxy) {\n        var gx = Math.floor(gxy[0] - info.gw / 2);\n        var gy = Math.floor(gxy[1] - info.gh / 2);\n        var gw = info.gw;\n        var gh = info.gh;\n\n        // If we cannot fit the text at this position, return false\n        // and go to the next position.\n        if (!canFitText(gx, gy, gw, gh, info.occupied)) {\n          return false;\n        }\n\n        // Actually put the text on the canvas\n        drawText(gx, gy, info, word, weight,\n                 (maxRadius - r), gxy[2], rotateDeg, attributes);\n\n        // Mark the spaces on the grid as filled\n        updateGrid(gx, gy, gw, gh, info, item);\n\n        return {\n          gx: gx,\n          gy: gy,\n          rot: rotateDeg,\n          info: info\n        };\n      };\n\n      while (r--) {\n        var points = getPointsAtRadius(maxRadius - r);\n\n        if (settings.shuffle) {\n          points = [].concat(points);\n          shuffleArray(points);\n        }\n\n        // Try to fit the words by looking at each point.\n        // array.some() will stop and return true\n        // when putWordAtPoint() returns true.\n        for (var i = 0; i < points.length; i++) {\n          var res = tryToPutWordAtPoint(points[i]);\n          if (res) {\n            return res;\n          }\n        }\n\n        // var drawn = points.some(tryToPutWordAtPoint);\n        // if (drawn) {\n        //   // leave putWord() and return true\n        //   return true;\n        // }\n      }\n      // we tried all distances but text won't fit, return null\n      return null;\n    };\n\n    /* Send DOM event to all elements. Will stop sending event and return\n       if the previous one is canceled (for cancelable events). */\n    var sendEvent = function sendEvent(type, cancelable, detail) {\n      if (cancelable) {\n        return !elements.some(function(el) {\n          var evt = document.createEvent('CustomEvent');\n          evt.initCustomEvent(type, true, cancelable, detail || {});\n          return !el.dispatchEvent(evt);\n        }, this);\n      } else {\n        elements.forEach(function(el) {\n          var evt = document.createEvent('CustomEvent');\n          evt.initCustomEvent(type, true, cancelable, detail || {});\n          el.dispatchEvent(evt);\n        }, this);\n      }\n    };\n\n    /* Start drawing on a canvas */\n    var start = function start() {\n      // For dimensions, clearCanvas etc.,\n      // we only care about the first element.\n      var canvas = elements[0];\n\n      if (canvas.getContext) {\n        ngx = Math.ceil(canvas.width / g);\n        ngy = Math.ceil(canvas.height / g);\n      } else {\n        var rect = canvas.getBoundingClientRect();\n        ngx = Math.ceil(rect.width / g);\n        ngy = Math.ceil(rect.height / g);\n      }\n\n      // Sending a wordcloudstart event which cause the previous loop to stop.\n      // Do nothing if the event is canceled.\n      if (!sendEvent('wordcloudstart', true)) {\n        return;\n      }\n\n      // Determine the center of the word cloud\n      center = (settings.origin) ?\n        [settings.origin[0]/g, settings.origin[1]/g] :\n        [ngx / 2, ngy / 2];\n\n      // Maxium radius to look for space\n      maxRadius = Math.floor(Math.sqrt(ngx * ngx + ngy * ngy));\n\n      /* Clear the canvas only if the clearCanvas is set,\n         if not, update the grid to the current canvas state */\n      grid = [];\n\n      var gx, gy, i;\n      if (!canvas.getContext || settings.clearCanvas) {\n        elements.forEach(function(el) {\n          if (el.getContext) {\n            var ctx = el.getContext('2d');\n            ctx.fillStyle = settings.backgroundColor;\n            ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n            ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n          } else {\n            el.textContent = '';\n            el.style.backgroundColor = settings.backgroundColor;\n            el.style.position = 'relative';\n          }\n        });\n\n        /* fill the grid with empty state */\n        gx = ngx;\n        while (gx--) {\n          grid[gx] = [];\n          gy = ngy;\n          while (gy--) {\n            grid[gx][gy] = true;\n          }\n        }\n      } else {\n        /* Determine bgPixel by creating\n           another canvas and fill the specified background color. */\n        var bctx = document.createElement('canvas').getContext('2d');\n\n        bctx.fillStyle = settings.backgroundColor;\n        bctx.fillRect(0, 0, 1, 1);\n        var bgPixel = bctx.getImageData(0, 0, 1, 1).data;\n\n        /* Read back the pixels of the canvas we got to tell which part of the\n           canvas is empty.\n           (no clearCanvas only works with a canvas, not divs) */\n        var imageData =\n          canvas.getContext('2d').getImageData(0, 0, ngx * g, ngy * g).data;\n\n        gx = ngx;\n        var x, y;\n        while (gx--) {\n          grid[gx] = [];\n          gy = ngy;\n          while (gy--) {\n            y = g;\n            singleGridLoop: while (y--) {\n              x = g;\n              while (x--) {\n                i = 4;\n                while (i--) {\n                  if (imageData[((gy * g + y) * ngx * g +\n                                 (gx * g + x)) * 4 + i] !== bgPixel[i]) {\n                    grid[gx][gy] = false;\n                    break singleGridLoop;\n                  }\n                }\n              }\n            }\n            if (grid[gx][gy] !== false) {\n              grid[gx][gy] = true;\n            }\n          }\n        }\n\n        imageData = bctx = bgPixel = undefined;\n      }\n\n      // fill the infoGrid with empty state if we need it\n      if (settings.hover || settings.click) {\n\n        interactive = true;\n\n        /* fill the grid with empty state */\n        gx = ngx + 1;\n        while (gx--) {\n          infoGrid[gx] = [];\n        }\n\n        if (settings.hover) {\n          canvas.addEventListener('mousemove', wordcloudhover);\n        }\n\n        if (settings.click) {\n          canvas.addEventListener('click', wordcloudclick);\n          canvas.addEventListener('touchstart', wordcloudclick);\n          canvas.addEventListener('touchend', function (e) {\n            e.preventDefault();\n          });\n          canvas.style.webkitTapHighlightColor = 'rgba(0, 0, 0, 0)';\n        }\n\n        canvas.addEventListener('wordcloudstart', function stopInteraction() {\n          canvas.removeEventListener('wordcloudstart', stopInteraction);\n\n          canvas.removeEventListener('mousemove', wordcloudhover);\n          canvas.removeEventListener('click', wordcloudclick);\n          hovered = undefined;\n        });\n      }\n\n      i = 0;\n      var loopingFunction, stoppingFunction;\n      if (settings.wait !== 0) {\n        loopingFunction = window.setTimeout;\n        stoppingFunction = window.clearTimeout;\n      } else {\n        loopingFunction = window.setImmediate;\n        stoppingFunction = window.clearImmediate;\n      }\n\n      var addEventListener = function addEventListener(type, listener) {\n        elements.forEach(function(el) {\n          el.addEventListener(type, listener);\n        }, this);\n      };\n\n      var removeEventListener = function removeEventListener(type, listener) {\n        elements.forEach(function(el) {\n          el.removeEventListener(type, listener);\n        }, this);\n      };\n\n      var anotherWordCloudStart = function anotherWordCloudStart() {\n        removeEventListener('wordcloudstart', anotherWordCloudStart);\n        stoppingFunction(timer);\n      };\n\n      addEventListener('wordcloudstart', anotherWordCloudStart);\n\n      var timer = loopingFunction(function loop() {\n        if (i >= settings.list.length) {\n          stoppingFunction(timer);\n          sendEvent('wordcloudstop', false);\n          removeEventListener('wordcloudstart', anotherWordCloudStart);\n\n          return;\n        }\n        escapeTime = (new Date()).getTime();\n        var drawn = putWord(settings.list[i]);\n        var canceled = !sendEvent('wordclouddrawn', true, {\n          item: settings.list[i], drawn: drawn });\n        if (exceedTime() || canceled) {\n          stoppingFunction(timer);\n          settings.abort();\n          sendEvent('wordcloudabort', false);\n          sendEvent('wordcloudstop', false);\n          removeEventListener('wordcloudstart', anotherWordCloudStart);\n          return;\n        }\n        i++;\n        timer = loopingFunction(loop, settings.wait);\n      }, settings.wait);\n    };\n\n    // All set, start the drawing\n    start();\n  };\n\n  WordCloud.isSupported = isSupported;\n  WordCloud.minFontSize = minFontSize;\n\n  // Expose the library as an AMD module\n  if (typeof define === 'function' && define.amd) {\n    define('wordcloud', [], function() { return WordCloud; });\n  } else if (typeof module !== 'undefined' && module.exports) {\n    module.exports = WordCloud;\n  } else {\n    global.WordCloud = WordCloud;\n  }\n\n})(this); //jshint ignore:line"],"mappings":"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"},"metadata":{},"sourceType":"script"}